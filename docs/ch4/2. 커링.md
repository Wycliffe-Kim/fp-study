# 커링 (Currying)

커링은 다항 함수를 단항 함수로 재사용하기 위한 방법 중 하나인데, 이를 제대로 이해하기 위해서는 비커리된 함수를 먼저 살펴봐야 한다.

다음의 예를 보도록 하자.

``` javascript
// javascript
function func(a, b, c) {
  return a + b + c;
}
```

``` python
# python
def func(a, b, c):
    return a + b + c
```

비커리된 함수의 경우 javascript의 경우에는 `func(1)`와 같이 호출할 경우에 `b`, `c`를 `undefined`로 채워서 함수를 호출하고, python의 경우에는 에러가 날 것이다.

그러나 커리된 함수의 경우에는 다음과 같은 결과를 낸다.

- `func(a)` -> `func(b, c)`
- `func(a, b)` -> `func(c)`
- `func(a, b, c)` -> `a + b + c`

이를 토대로 커링을 다시 정의하면 **커링이란 다변수 함수가 인수를 전부 받을 때까지 실행을 보류, 또는 지연시켜 단계별로 나뉜 단항 함수의 순차열로 변환시키는 기법**이다.

이러한 커링을 수동으로 구현하게 되면 다음과 같이 구현할 수 있다.

``` javascript
// javascript
function curry(fn) {
  return (firstArg) => {
    return (secondArg) => {
      return fn(firstArg, secondArg);
    }
  }
}
```

``` python
# python
def curry(fn):
    def first_curry(first_arg):
        def second_curry(second_arg):
            return fn(first_arg, second_arg)
        return second_curry
    return first_curry
```

이러한 커링을 사용한 예제를 보면 다음과 같다. 참고로 커링은 인수의 개수에 상관 없이 커링을 수행하기 위해 라이브러리를 사용하는 것이 좋다. javascript에서는 lodash 혹은 ramda를 사용하고 파이썬에서는 pydash 혹은 toolz를 사용한다.

``` javascript
// javascript
const R = require('ramda');

const add = R.curry((a, b) => a + b);
const plus2 = add(2);
plus2(3); // 5
```

``` python
# python
import pydash

add = pydash.curry(lambda a, b: a + b)
plus2 = add(2)
plus2(3) # 5
```

그럼 커링은 어디에 사용하는 것이 적절할까? 보통은 다음과 같은 때에 사용한다.

- 함수 팩토리 모방
- 재사용 가능한 모듈적 함수 템플릿 구현

## 함수 팩토리 모방

DB 혹은 객체에서 데이터를 읽어오는 객체지향 코드를 간단하게 살펴보도록 한다.

``` javascript
// javascript
class StudentStore {
  findStudent(ssn) {}
}

class DbStudentStore extends StudentStore {
  findStudent(ssn) {
    return db.find(ssn);
  }
}

class CacheStudentStore extends StudentStore {
  findStudent(ssn) {
    return someDict[ssn];
  }
}

function getStudentStore(useDb) {
  return useDb ? new DbStudentStore() : new CacheStudentStore();
}

const store = getStudentStore(true); // or false
store.findStudent('444-44-4444');
```

``` python
# python
class StudentStore:
    def find_student(ssn):
        pass

class DbStudentStore(StudentStore):
    def find_student(ssn):
        return db.find(ssn)

class CacheStudentStore(StudentStore):
    def find_student(ssn):
        return some_dict[ssn]

def get_student_store(use_db):
    return DbStudentStore() if use_db else CacheStudentStore()

store = get_student_store(true) # or false
store.find('444-44-4444')
```

커링을 사용하면 이를 다음과 같이 변경할 수 있다.

``` javascript
// javascript
const R = require('ramda');

const fetchStudentFromDb = R.curry((db, ssn) => find(db, ssn));
const fetchStudentFromCache = R.curry((someDict, ssn) => someDict[ssn]);
const findStudent = useDb ? fetchStudentFromDb(db) : fetchStudentFromCache(someDict);

findStudent('444-44-4444');
```

``` python
# python
import pydash

fetch_student_from_db = pydash.curry(lambda db, ssn: find(db, ssn))
fetch_student_from_cache = pydash.curry(lambda some_dict, ssn: some_dict[ssn])
find_student = fetch_student_from_db(db) if use_db else fetch_student_from_cache(some_dict)

find_student('444-44-4444')
```

## 재사용 가능한 함수 템플릿 구현

다음과 같이 재사용 컴포넌트를 만들 때에도 커링은 유용하다.

``` javascript
// javscript
const R = require('ramda');

const logger = R.curry((successTitle, failTitle, error, message) => 
  console.log(`[${error ? failTitle : successTitle}]`, message));

const loggerCommon = logger('SUCCESS', 'FAIL');

const loggerInfo = loggerCommon(false);
loggerInfo('test message'); // [SUCCESS] test message

const loggerError = loggerCommon(true);
loggerError('test message'); // [FAIL] test message
```

``` python
# python
import pydash

logger = pydash.curry(lambda success_title, fail_title, error, message: 
    print(f'[{fail_title if error else success_title}]', message))

logger_common = logger('SUCCESS', 'FAIL')

logger_info = logger_common(False)
logger_info('test message') # [SUCCESS] test message

logger_error = logger_common(True)
logger_error('test message') # [FAIL] test message
```