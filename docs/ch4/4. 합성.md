# 합성

함수형 프로그램의 목표는 합성(함수형 사상의 중추인)을 유도하는 필요한 자료구조를 얻는 것이다.

합성이란 용어는 그 자체로 작업을 분해하는 것을 전제한다. 즉 합성이란 용어 자체가 모듈화를 권장한다(어쩌면 강제한다).

작업(혹은 행위)을 모듈화하도록 하는 합성의 이러한 특징은 함수형 프로그래밍의 특성인 순수함수, 참조 투명성, 부수효과 없는 함수와 잘 맞는다. 이러한 함수들로 잘게 쪼갠 후 그것을 합성하여 더욱 복잡한 기능을 수행하도록 만드는 것이다.

이러한 합성에 대한 예제를 우리는 1장에서 잠시 살펴봤다(참고로 `compose` 함수 외에도 `pipe` 함수도 있는데 `compose`는 뒤에서 앞으로 합성하고 `pipe`는 앞에서 뒤로 합성한다).

``` javascript
// javascript
const R = require('ramda');

const find = R.curry((db, id) => {
  let obj = db.find(id);
  if (obj == null) {
    throw new Error('객체를 찾을 수 없습니다');
  }
  return obj;
});

const fullname = (student) => `${student.ssn}, ${student.firstname}, ${student.lastname}`;

const showStudent = R.compose(
  console.log,
  fullname,
  find
);

showStudent('444-44-4444');
```

``` python
# python
import pydash
import toolz as tz

def find_curry(db, id):
    obj = db.find(id)
    if obj == None:
        raise ValueError('객체를 찾을 수 없습니다.')
    return obj

find = pydash.curry(find_curry)

fullname = lambda student: f'{student["ssn"]}, {student["firstname"]}, {student["lastname"]}'

show_student = tz.compose(
    print,
    fullname,
    find
)

show_student('444-44-4444')
```

이처럼 함수를 잘게 쪼개어 최대한의 단일성의 원칙을 준수하게끔 한 후, 그것을 합쳐 중요한 기능을 하는 함수로 제작하는 것이다.

그런데 이러한 함수의 합성을 볼 때 우리가 또한 음미해야 하는 것이 있는데, 그것은 **함수의 서술부(선언 및 정의)와 평가부(호출 및 수행)가 가독성 좋게 분리되어 있다**는 것이다. 이것이 곧 함수 합성의 미학이다.

함수 합성은 앞에서 잠시 말했던 것처럼 연결되는 함수끼리의 입출력이 호환되기만 하면 가능하다.

만약에 $f(g(h(x)))$로 합성을 표현한다면 함수 $f$의 입력은 함수 $g$의 출력 형식과 같아야 하고, 함수 $g$의 입력은 함수 $h$의 출력 형식과 같아야 한다.

또한 이러한 함수 합성은 순수한 함수와 불순한 함수를 분리하도록 유도한다. 위의 코드에서 보는 바처럼 db에서 읽어오는 함수와 IO에 출력하는 함수가 연산부(`fullname`)와 분리되어 있다.

합성한 함수의 모습을 잘 보게 되면 인수가 표기되지 않는 것을 볼 수 있다. 이러한 특징 때문에 합성을 무인수 프로그래밍이라고도 부른다.

그러나 이러한 무인수 프로그래밍은 그 자체로 단점을 또한 내포하고 있다. 그것은 명령형에서 다루는 에러 처리를 다룰 수 없다는 것이다. 함수형 프로그래밍에서 예외를 처리하도록 하는 부수효과는 용납할 수 없는 것이다. 위의 코드처럼 `throw`(`raise`)를 사용할 수는 있지만 사용해서는 안 된다. 함수형 프로그래밍은 무릇 부수효과를 야기해서는 안 된다. 그 지점에서부터 이미 함수형 프로그래밍의 패러다임에서 벗어나게 된 것이다. 그러면 이러한 에러 처리를 어떻게 할 수 있을까? 부수효과를 두려워하여 그냥 `null`이나 `undefined`(`None`)을 반환해야 할까?

이러한 처리는 추후에 모나드라는 개념을 통해서 해결 가능하다. 모나드라는 개념을 통하면 성능 면에서도, 가독성 면에서도 훨씬 효율적인 코드를 작성할 수 있다.

그럼에도 조건 로직을 위한 어떤 제어 로직을 함수형 프로그래밍에 삽입할 수 없을까? 이를 위해 존재하는 것이 함수 조합기다.

## 함수 조합기

함수 조합기의 종류는 상당하다. 그러나 그 중에서도 많이 쓰는 것을 나열하면 다음과 같다.

- identity
- tap
- alternation
- sequence
- fork(혹은 join)

### identity
이는 항등식이다. 즉 주어진 인수와 똑같은 값을 반환하는 함수이다. 추후에 우리는 함수자 혹은 모나드라는 개념을 배우게 될 것이다. 그때 값을 부수효과로부터 보호하고 적절한 연산을 직접적으로 수행할 수 없도록 하기 위해 컨테이너로 감싸게 될텐데 그러한 컨테이너로부터 값을 꺼내오거나, 혹은 테스트 할 때 합성의 중간 지점에서 값을 평가할 때 사용된다.

### tap
보통 void 함수를 합성에서 연결할 때 해당 조합기가 사용된다. 주로 중간에 디버깅을 하거나 하는 용도로 사용된다.

``` javascript
// javascript
const R = require('ramda');

const add = R.curry((a, b) => a + b);
const mul = R.curry((a, b) => a * b);

const calc = R.compose(
  R.tap(console.log),
  mul(3),
  R.tap(console.log),
  add(3)
);

calc(2);
// output
// >> 5
// >> 15
```

``` python
# python
import pydash
import pydash
import toolz as tz

add = pydash.curry(lambda a, b: a + b)
mul = pydash.curry(lambda a, b: a * b)

tap = pydash.curry(lambda interceptor, value: pydash.tap(value, interceptor))

calc = tz.compose(
  tap(print),
  mul(3),
  tap(print),
  add(3)
)

calc(2)
# output
# >> 5
# >> 15
```

### alternation

선택 조합기는 함수 2개를 인수로 받아 첫 번째 함수의 반환 값이 있으면 첫 번째 함수의 결과를 없으면 두 번째 함수의 결과를 반환한다.

``` javascript
// javascript
const R = require('ramda');

const add = R.curry((a, b) => a != null && b != null ? console.log(a + b) : undefined);
const alt = R.curry((func1, func2, value) => func1(value) || func2(value));

const someFunc = alt(add(2), console.log);

const success = R.compose(
  someFunc,
  () => 1
);

const fail = R.compose(
  someFunc,
  () => undefined
);

success();
fail();
```

``` python
# python
import pydash
import toolz as tz

add = pydash.curry(lambda a, b: print(a + b) if a is not None and b is not None else None)
alt = pydash.curry(lambda func1, func2, value: func1(value) or func2(value))

some_func = alt(add(2), print)

success = tz.compose(
  some_func,
  lambda: 1
)

fail = tz.compose(
  some_func,
  lambda: None
)

success()
fail()
```

### sequence

순차열 조합기는 함수를 순차적으로 하나의 입력을 통해 수행한다.

``` javascript
// javascript
const R = require('ramda');
const _ = require('lodash');

const seq = (funcs) => (val) => _(funcs).forEach((fn) => fn(val));

const addLog = R.curry((a, b) => console.log(a + b));
const mulLog = R.curry((a, b) => console.log(a * b));
const subLog = R.curry((a, b) => console.log(a - b));

const calc = R.compose(
  seq([addLog(3), mulLog(3), subLog(3)]),
  () => 3
);

calc();
```

``` python
# python
import pydash
import toolz as tz

seq = lambda funcs: lambda val: pydash.for_each(funcs, lambda fn: fn(val))

add_log = pydash.curry(lambda a, b: print(a + b))
mul_log = pydash.curry(lambda a, b: print(a * b))
sub_log = pydash.curry(lambda a, b: print(a - b))

calc = tz.compose(
  seq([add_log(3), mul_log(3), sub_log(3)]),
  lambda: 3
)

calc()
```

### fork (join)

fork 조합기는 하나의 자원을 두 가지 방법으로 처리 후 그 결과를 다시 조합한다.

``` javascript
// javascript
const _ = require('lodash');

const fork = (join, func1, func2) => (val) => join(func1(val), func2(val));

const sum = (a, b) => a + b;
const total = (arr) => _(arr).reduce(sum);
const size = (arr) => arr.length;
const divide = (a, b) => a / b;

const average = fork(divide, total, size);
average([80, 90, 100]);
```

``` python
# python
import pydash

fork = lambda join, func1, func2: lambda val: join(func1(val), func2(val))

sum = lambda a, b: a + b
total = lambda arr: pydash.reduce_(arr, sum)
size = lambda arr: len(arr)
divide = lambda a, b: a / b

average = fork(divide, total, size)
average([80, 90, 100])
```