# 함수 최적화 방법

## 선택 조합기 사용

4부에서 선택 조합기에 대해서 살펴 보았다. 선택 조합기란 어떤 값이 있으면 1번 함수를 수행하고 없으면 2번 함수를 수행하게끔 만드는 조합기였다. 이 조합기를 사용하면 함수 스택의 깊이를 조금 줄일 수 있다.

``` javascript
// javascript
const R = require('ramda');

const add = R.curry((a, b) => a != null && b != null ? console.log(a + b) : undefined);
const alt = R.curry((func1, func2, value) => func1(value) || func2(value));

const someFunc = alt(add(2), console.log);

const success = R.compose(
  someFunc,
  () => 1
);

const fail = R.compose(
  someFunc,
  () => undefined
);

success();
fail();
```

``` python
# python
import pydash
import toolz as tz

add = pydash.curry(lambda a, b: print(a + b) if a is not None and b is not None else None)
alt = pydash.curry(lambda func1, func2, value: func1(value) or func2(value))

some_func = alt(add(2), print)

success = tz.compose(
  some_func,
  lambda: 1
)

fail = tz.compose(
  some_func,
  lambda: None
)

success()
fail()
```

## 체이닝 함수의 끝에 `value()` 사용

javascript의 lodash(python의 pydash)에는 `chain` 함수가 있다. 이 `chain` 함수로 함수 체이닝을 한 후 마지막에 `value` 함수를 호출하면 함수의 평가를 `value`가 호출된 시점에 한다. 이와 같은 방식으로 하게 되면 역시 함수 컨텍스트가 차지하는 메모리의 측면에서 최적화를 수행할 수 있다. 이에 대한 예제는 1장에서 찾을 수 있다.

``` javascript
// javascript
const _ = require('lodash');

const arr = _.chain(enrollment)
      .filter((student) => student.enrolled > 1)
      .map((student) => student.grade)
      .value();
average(arr);
```

``` python
# python
import pydash

arr = (pydash.chain(enrollment)
           .filter_(lambda student: student['enrolled'] > 1)
           .map_(lambda student: student['grade'])
           .value())
average(arr)
```

## 메모화 (memoization)

메모화는 함수 호출 시 함수 인수로 키 값을 만들고 그 결과를 미리 캐싱해 놓는 기법이다. 그리고 이후에 이와 같은 인수로 다시 호출할 경우 다시 계산하는 것이 아니라 캐싱된 결과를 출력하는 것이다.

이러한 메모화는 계산량이 많고, 또 같은 결과를 도출해내는 반복이 잦은 함수에 적용하는 것이 좋다.

메모화의 로직을 그림으로 보면 다음과 같다.

![memoization logic](../../images/memozation%20logic.png)

그리고 이 메모화에 대한 예제 코드는 다음과 같다.

``` javascript
// javascript
const _ = require('lodash');
const fp = require('lodash/fp');

let count = 0;
const add = (a, b) => {
  count += 1;
  return a + b;
}
const addMemoized = fp.memoize(add);

const logCount = () => console.log(count);
const resetCount = () => { count = 0; }
const loop = (func) => _.range(10000000).forEach(func);
const work = (func) => fp.compose(
  logCount,
  () => loop(() => func()),
  resetCount
)();

work(() => add(1, 2));
work(() => addMemoized(1, 2));
// output
// >> 10000000
// >> 1
```

``` python
# python
import pydash
import toolz as tz

global count
count = 0

def add(a, b):
    global count
    count += 1
    return a + b
  
def log_count(): 
    global count
    print(count)
    
def reset_count():
    global count
    count = 0
    
def loop(func):
    pydash.for_each(range(1000000), func)

add_memoized = pydash.memoize(add)

work = lambda func : tz.compose(
        lambda v: log_count(),
        lambda v: loop(lambda: func()),
        reset_count
    )()
    
work(lambda: add(1, 2))
work(lambda: add_memoized(1, 2))
# output
# >> 10000000
# >> 1
```