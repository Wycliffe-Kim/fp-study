# 콜백 지옥

비동기 처리에 대해서 어떻게 적절하게 할지 살펴보기 이전에 기존 방식의 문제점을 한 번 살펴보도록 한다.

콜백이란 함수 자체를 다른 함수에 종속적이게 해서(이 자체가 이미 문제다), 그 함수가 콜백의 대상이 된 함수를 호출하게 하는 것이다.

콜백 함수에 대한 코드 예제는 다음과 같다.

먼저 이후의 예제들을 위한 코드들을 모듈화 하도록 한다.

``` javascript
// javascript
// getJSON.js
const axios = require('axios');

function getJSONCallback(url, success, fail) {
  axios.get(url)
  .then((res) => success(res.data))
  .catch((err) => fail(err));
}

function getJSONPromise(url) {
  return new Promise((resolve, reject) => 
    axios.get(url)
    .then((res) => resolve(res.data))
    .catch((err) => reject(err)));
}

module.exports = {
  getJSONCallback,
  getJSONPromise
};

// average.js
const fp = require('lodash/fp');
const R = require('ramda');

const fork = (join, func1, func2) => (value) => join(func1(value), func2(value));

const average = fp.compose(
  Math.ceil,
  fork(R.divide, R.sum, R.length)
);

module.exports = average;
```

``` python
# python
# fetch.py
import aiohttp

async def fetch(url):
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(url) as resp:
                if resp.status == 200:
                    return await resp.text()
        except (aiohttp.ClientError or
                aiohttp.WebSocketError or
                aiohttp.ContentTypeError or
                aiohttp.ClientPayloadError or
                aiohttp.ServerTimeoutError or
                aiohttp.ClientResponseError or
                aiohttp.ClientConnectorError or
                aiohttp.ClientHttpProxyError or
                aiohttp.ClientConnectionError or
                aiohttp.ServerConnectionError or
                aiohttp.WSServerHandshakeError or
                aiohttp.ServerDisconnectedError or
                aiohttp.ClientProxyConnectionError or
                aiohttp.ClientConnectorCertificateError) as err:
            raise ValueError(err)

# get_json.py
import asyncio
import json
from promise import Promise

from .fetch import fetch

def get_json_callback(url, success, fail):
    async def run():
        try:
            data = await fetch(url)
            success(json.loads(data))
        except ValueError as err:
            fail(err)
    
    asyncio.run(asyncio.wait([run()]));
  
def get_json_promise(url):
    async def promise_func(resolve, reject):
        try:
            data = await fetch(url)
            resolve(json.loads(data))
        except ValueError as err:
            reject(err)
              
    return Promise(lambda resolve, reject: asyncio.run(asyncio.wait([promise_func(resolve, reject)])))

# average.py
import toolz as tz
import pydash
import math

def average(arr):
    def fork(join, func1, func2): 
        def inner_fork(value):
            return join(func1(value), func2(value))
        return inner_fork

    return tz.compose(
        math.ceil,
        fork(pydash.divide, pydash.sum_, len)
    )(arr)
```

이제 콜백 지옥에 대한 예제 코드를 보자(참고로 IO 모나드는 5장에서 사용했던 모나드이다).

``` javascript
// javascript
const R = require('ramda');
const axios = require('axios');

function getJSONCallback(url, success, fail) {
  axios.get(url)
  .then((res) => success(res.data))
  .catch((err) => fail(err));
}

const log = R.curry((title, message) => console.log(title, message));

getJSONCallback('http://localhost:5555/students', (data) => {
  const grades = R.map((student) => student.grade)(data);
  const grade = average(grades);
  const io = (grade) => IO.of(grade).map(log('callbackHell success')).run();
  io(grade);
}, (err) => {
  log('callbackHell fail', err);
});
```

``` python
# python
import pydash

from .average import average
from .get_json import get_json_callback

log = pydash.curry(lambda title, message: print(title, message))

def success(data):
    grades = pydash.map_(data, lambda student: student['grade'])
    grade = average(grades)
    io = lambda grade: IO.of(grade).map(log('callback_hell success')).run()
    io(grade)
  
def fail(err):
    log('callback_hell fail', err)
  
get_json_callback('http://localhost:5555/students', success, fail)
```

위의 코드에서는 깊이가 얕지만, 만약에 `success`와 `fail` 함수 내부에서 또 비동기 호출을 한다고 치면, 상상만 해도 끔찍한 코드가 작성될 것이다.