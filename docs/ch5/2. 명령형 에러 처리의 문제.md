# 명령형 에러 처리의 문제

개발자는 늘 실패 케이스를 마음 속으로 대비해야 한다. 그렇기 때문에 이를 위해 `try-catch`(`try-except`), 혹은 `if (null`)(`if None`)을 이곳 저곳에 도배할 수밖에 없다.

그러나 이러한 예외처리 구문 도배는 코드를 헤아리기 어렵게 만든다. 특히 이 구문의 깊이가 깊어지면 깊어질수록 코드의 가독성은 현저하게 떨어지고, 사실상 성능까지도 이슈가 생기기 마련이다.

다음은 명령형 에러 처리의 흔한 코드이다.

``` javascript
// javascript
try {
  // ...
  try {
    // ...
  } catch(e1) {
    // ...
  }
} catch(e) {
  // ...
  try {
    // ...
  } catch(e2) {
    // ...
  }
}
```

``` python
# python
try:
  # ...
  try:
    # ...
  except e1:
    # ...
except e:
  # ...
  try:
    # ...
  except e2:
    # ...
```

명령형 에러 처리 코드는 단순히 코드의 가독성 측면에서의 이슈만 있는 것이 아니다. 실질적인 부수효과에 대해서도 자유로울 수 없다.

어떤 로직을 처리하다가 예외로 코드 블럭에서 빠져나오게 되면 그 다음 로직이 수행되었을 것이란 확신을 할 수 없으며, 에러 처리 구문이 깊어질수록 어디에서 에러가 났는지를 체크하기 위해 온갖 판박이 코드를 이곳저곳에 붙여야만 한다.

---

그렇다면 함수형 프로그래밍은 왜 예외를 던지지 않을까?
- 함수 합성이 불가능하다.
- 참조 투명성의 원칙에 위배된다.
- 예기치 않게 스택이 풀리게 되면 전체 시스템에 영향을 미치는 부수효과를 일으킨다.
- 예외가 발생하면 지역 스택과 환경에서 벗어나게 된다.
- 함수를 호출하는 사람이 예외 처리를 위한 `try-catch` 블록을 다시 꺼내 써야 하므로, 부담을 다시 안게 된다.

그럼 이러한 문제를 어떻게 해결할 수 있는가?