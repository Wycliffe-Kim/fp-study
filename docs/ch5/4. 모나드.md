# 모나드

모나드는 특정한 케이스를 특정한 로직에 위임하여 처리할 수 있게 해준다는 점에서만 함수자와 다르다.

만약에 `half`라는 함수가 있따고 생각해보자. 이 함수는 어떤 숫자를 입력으로 받으면 그 숫자를 2로 나누어 출력해주는 함수다. 그런데 만약에 이 함수를 짝수일 경우만(특정 케이스) 수행할 수 있도록 하고 싶다면 어떻게 해야 할까?

그럴 때에는 `Wrapper`와 비슷하나, 처리를 물 흐르듯이 흘러가게 할 수 있는 `Empty`라는 함수자를 하나 더 만들어야 한다.

``` javascript
// javascript
class Empty {
  map(f) {
    return this;
  }

  fmap(f) {
    return new Empty();
  }
}
```

``` python
# python
class Empty:
    def map(self, f):
        return self

    def fmap(self, f):
        return Empty()
```

그 후에 코드를 다음과 같이 작성하고 결과를 보면 다음과 같다.

``` javascript
// javascript
const isEven = (n) => n % 2 === 0;
const half = (val) => isEven(val) ? new Wrppaer(val / 2) : new Empty();

half(4); // Wrapper(2)
half(3); // Empty()

half(4).fmap(add(3)); // Wrapper(7)
half(3).fmap(add(3)); // Empty()
```

``` python
# python
is_even = lambda n: n % 2 == 0
half = lambda val: Wrapper(val / 2) if is_even(val) else Empty()

half(4) # Wrapper(2)
half(3) # Empty()

half(4).fmap(add(3)) # Wrapper(7)
half(3).fmap(add(3)) # Empty()
```

이와 같이 모나드를 구성하면 비록 잘못된 값이 반환되더라도 문제 없이 처리를 물 흐르듯이 할 수 있다.

이러한 모나드에 대해서 조금 더 상세하게 살펴보도록 하자.

## 모나드 인터페이스

모나드는 저마다 개성이 다르고 목적에 따라 의미도 달라진다. 그렇기에 구현 로직도 다 제각각이다. 그럼에도 모나드가 지켜야 하는 인터페이스가 있다. 그것은 다음과 같다.

- 형식 생성자: 모나드형을 생성한다.
- 단위 함수: 어떤 형식의 값을 모나드에 삽입한다. 보통은 `of`라고 칭한다.
- 바인드 함수: 연산을 서로 체이닝한다. 앞서는 `fmap`이라고 했지만 앞으로는 `map`이라고 하겠다.
- 조인 연산: 모나드 자료구조를 눌려 편다. 모나드 반환 함수를 다중 합성할 때 중요하다.

## 모나드 종류

### `Maybe`, `Either` 모나드

이 모나드들은 값이 없는 상태를 모형화 할 수 있는 모나드이다. 이 두 개의 형으로 에러를 구상화할 수 있다. 이 모나드들로는 다음의 일들을 처리할 수 있다.
- 불순 코드를 격리
- `null` 체크 로직을 격리
- 예외를 던지지 않음
- 함수 합성을 지원
- 기본값 제공 로직을 한 곳에 모음

#### `Maybe` 모나드

`Maybe` 모나드는 `null` 체크를 일원화 할 수 있다.

``` javascript
// javascript
class Maybe {
  get isNothing() {
    return false;
  }

  get isJust() {
    return false;
  }

  static just(value) {
    return new Just(value);
  }

  static nothing() {
    return new Nothing();
  }

  static fromNullable(value) {
    return value != null ? Maybe.just(value) : Maybe.nothing();
  }

  static of(value) {
    return Maybe.just(value);
  }
}

class Nothing extends Maybe {
  map(f) {
    return this;
  }

  get value() {
    throw new TypeError('Nothing 값을 가져올 수 없습니다.');
  }

  getOrElse(other) {
    return other;
  }

  filter(f) {
    return this._value;
  }

  chain(f) {
    return this;
  }

  toString() {
    return 'Maybe.Nothing';
  }

  get isNothing() {
    return true;
  }
}

class Just extends Maybe {
  constructor(value) {
    super();
    this._value = value;
  }

  get value() {
    return this._value;
  }

  map(f) {
    return Maybe.fromNullable(f(this._value));
  }

  getOrElse(other) {
    return this._value;
  }

  filter(f) {
    Maybe.fromNullable(f(this._value) ? this._value : null);
  }

  chain(f) {
    return f(this._value);
  }

  toString() {
    return `Maybe.Just(${this._value})`;
  }

  get isJust() {
    return true;
  }
}
```

``` python
# python
class Maybe:
    @property
    def is_nothing(self):
        return False
      
    @property
    def is_just(self):
        return False
    
    @staticmethod
    def just(value):
        return Just(value)
      
    @staticmethod
    def nothing():
        return Nothing()
      
    @staticmethod
    def from_nullable(value):
        return Maybe.just(value) if value != None else Maybe.nothing()
      
    @staticmethod
    def of(value):
        return Maybe.just(value)
    
class Just(Maybe):
    def __init__(self, value):
        self._value = value
        
    @property
    def value(self):
        return self._value
      
    @property
    def is_just():
        return True
      
    def map(self, f):
        return Maybe.from_nullable(f(self._value))
      
    def get_or_else(self, other=None):
        return self._value
      
    def filter(self, f):
        Maybe.from_nullable(self._value if f(self._value) else None)
        
    def chain(self, f):
        return f(self._value)
      
    def __str__(self):
        return f'Maybe.Just({self._value})'
    
class Nothing(Maybe):
    _value = None
    
    @property
    def value(self):
        raise TypeError('Nothing 값을 가져올 수 없습니다.')

    @property
    def is_nothing(self):
        return True
      
    def map(self, f=None):
        return self
      
    def get_or_else(self, other):
        return other
      
    def filter(self, f=None):
        return self._value
      
    def chain(self, f=None):
        return self
      
    def __str__(self):
        return 'Maybe.Nothing'
```

사실상 `Just`와 `Nothing`은 `map`에 따라서 다른 연산을 수행한다. 그렇지만 추상화 형태로 제공되기 때문에 중간에 `null`이 제공된다고 하더라도 연산은 물 흐르듯이 수행되어 완료된다.

이를 이용한 예제를 한 번 살펴보도록 하자.

``` javascript
// javascript
const R = require('ramda');

class StudentDB {
  students = [
    {
      firstname: 'studentA',
      lastname: 'A',
      ssn: '111-11-1111'
    },
    {
      firstname: 'studentB',
      lastname: 'B',
      ssn: '222-22-2222'
    },
    {
      firstname: 'studentC',
      lastname: 'C',
      ssn: '333-33-3333'
    },
    {
      firstname: 'studentD',
      lastname: 'D',
      ssn: '444-44-4444'
    },
  ];
}

const findFromDB = (db, ssn) => db.students.filter((student) => student.ssn === ssn)[0];

const safeFindObject = R.curry((db, id) => Maybe.fromNullable(findFromDB(db, id)));
const safeFindStudent = safeFindObject(new StudentDB());
const address = safeFindStudent('444-44-4444').map(R.prop('address')).getOrElse('주소가 없습니다.');
const ssn = safeFindStudent('444-44-4444').map(R.prop('ssn')).getOrElse('SSN이 없습니다.');

console.log(address, ssn); // 주소가 없습니다. 444-44-4444
```

``` python
# python
import pydash
import toolz as tz

class StudentDB:
    def __init__(self):
        self.students = [
            {
                'firstname': 'studentA',
                'lastname': 'A',
                'ssn': '111-11-1111'
            },
            {
                'firstname': 'studentB',
                'lastname': 'B',
                'ssn': '222-22-2222'
            },
            {
                'firstname': 'studentC',
                'lastname': 'C',
                'ssn': '333-33-3333'
            },
            {
                'firstname': 'studentD',
                'lastname': 'D',
                'ssn': '444-44-4444'
            },
        ]
    
def find_from_db(db, ssn):
    students = list(tz.filter(lambda student: student['ssn'] == ssn, db.students))
    if len(students) == 0:
        return None
    
    return students[0]

safe_find_object = pydash.curry(lambda db, id: Maybe.from_nullable(find_from_db(db, id)))
safe_find_student = safe_find_object(StudentDB())
address = safe_find_student('444-44-4444').map(prop('address')).get_or_else('주소가 없습니다.')
ssn = safe_find_student('444-44-4444').map(prop('ssn')).get_or_else('SSN이 없습니다.')

print(address, ssn) # 주소가 없습니다. 444-44-4444
```

위와 같이 에러 체크가 내부적으로 이루어지며, 에러가 있다면 나중에 `getOrElse`(`get_or_else`) 함수에서 에러가 있는 상황에 대비해 값을 출력할 수 있도록 해준다.

#### `Either` 모나드

`Either`는 `Maybe`와 약간 다르다. `Either`는 절대로 동시에 발생하지 않는 두 값 `a`, `b`를 논리적으로 구분한 자료구조로서, 다음 두 경어를 모형화한 형식이다.

- `Left(a)`: 에러 메시지 또는 예외 객체를 담는다.
- `Right(b)`: 성공한 값을 담는다.

다음은 `Either` 모나드를 구현한 코드다.

``` javascript
// javascript
class Either {
  constructor(value) {
    this._value = value;
  }

  get value() {
    return this._value;
  }

  static left(value) {
    return new Left(value);
  }

  static right(value) {
    return new Right(value);
  }

  static fromNullable(value) {
    return value != null ? Either.right(value) : Either.left(value);
  }

  static of(value) {
    return Either.right(value);
  }
}

class Left extends Either {
  get value() {
    throw TypeError(`Left(${this._value}) 값을 가져올 수 없습니다.`);
  }

  map(f) {
    return this;
  }

  getOrElse(other) {
    return other
  }

  orElse(f) {
    return f(this._value);
  }

  chain(f) {
    return this;
  }

  getOrElseThrow(value) {
    return new Error(value);
  }

  filter(f) {
    return this;
  }

  toString() {
    return `Either.Left(${this._value})`;
  }
}

class Right extends Either {
  map(f) {
    return Either.fromNullable(f(this._value));
  }

  getOrElse(other) {
    return this._value;
  }

  orElse() {
    return this;
  }

  chain(f) {
    return f(this._value);
  }

  getOrElseThrow() {
    return this._value;
  }

  filter(f) {
    return Either.fromNullable(f(this._value) ? this._value : null);
  }

  toString() {
    return `Either.Right(${this._value})`;
  }
}
```

``` python
# python
class Either:
    def __init__(self, value):
        self._value = value
        
    @property
    def value(self):
        return self.value
    
    @staticmethod
    def left(value):
        return Left(value)
    
    @staticmethod
    def right(value):
        return Right(value)
    
    @staticmethod
    def from_nullable(value):
        return Either.right(value) if value != None else Either.left(value)
    
    @staticmethod
    def of(value):
        return Either.right(value)
    
class Left(Either):
    @property
    def value(self):
        raise TypeError(f'Left({self._value}) 값을 가져올 수 없습니다.')
    
    def map(self, f=None):
        return self
    
    def get_or_else(self, other):
        return other
    
    def or_else(self, f):
        return f(self._value)
    
    def chain(self, f=None):
        return self
    
    def get_or_else_throw(self, value):
        return ValueError(value)
    
    def filter(self, f=None):
        return self
    
    def __str__(self):
        return f'Either.Left({self._value})'
    
class Right(Either):
    def map(self, f):
        return Either.from_nullable(f(self._value))
      
    def get_or_else(self, other=None):
        return self._value
      
    def or_else(self):
        return self
      
    def chain(self, f):
        return f(self._value)
      
    def get_or_else_throw(self):
        return self._value
      
    def filter(self, f):
        return Either.from_nullable(self._value if f(self._value) else None)
      
    def __str__(self):
        return f'Either.Right({self._value})'
```

`Maybe`와의 차이점은 딱 하나다. 그것은 `Either`는 `Maybe`와는 다르게 함수 적용이 가능하다는 것이다. 그래서 `Either` 모나드를 이용하면 다음과 같이 에러의 경우 특정 함수를 수행하도록 할 수 있다.

``` javascript
// javascript
const safeFindObject = fp.curry((db, id) => Either.fromNullable(findFromDB(db, id)));
const safeFindStudent = safeFindObject(new StudentDB());
safeFindStudent('444-44-4444').map(fp.prop('address')).orElse((val) => console.log('error', val));
console.log(safeFindStudent('444-44-4444').map(fp.prop('ssn')));
```

``` python
# python
safe_find_object = pydash.curry(lambda db, id: Either.from_nullable(find_from_db(db, id)))
safe_find_student = safe_find_object(StudentDB())
safe_find_student('444-44-4444').map(prop('address')).or_else(lambda val: print('error', val))
print(safe_find_student('444-44-4444').map(prop('ssn')).get_or_else('SSN이 없습니다.'))
```

### `IO` 모나드

`IO` 모나드를 통해서는 파일 읽기, 쓰기, 화면 출력 등의 IO 연산을 참조 투명성에 최대한 위반되지 않게 수행할 수 있다.

IO 연산을 중간 중간에 하게 되면 언제 해당 값이 변했는지, 또 변할지 알 수 없어서 부수효과를 일으키기 십상이다. 그러므로 이러한 연산은 중간에 어떤 방해가 걸리지 않도록 한 번에 수행하도록 하는 것이 좋다. `IO` 모나드가 바로 이러한 일을 할 수 있도록 해준다.

다음은 `IO` 모나드 구현이다.

``` javascript
// javascript
const _ = require('lodash');

class IO {
  constructor(effect) {
    if (!_.isFunction(effect)) {
      throw 'IO 사용법: 함수는 필수입니다!';
    }
    this._effect = effect;
  }

  static of(value) {
    return new IO(() => value);
  }

  static from(f) {
    return new IO(f);
  }

  map(f) {
    return new IO(() => f(this._effect()));
  }

  chain(f) {
    return f(this._effect());
  }

  run() {
    return this._effect();
  }
}
```

``` python
# python
import pydash

class IO:
    def __init__(self, effect):
        if not pydash.is_function(effect):
            raise TypeError('IO 사용법: 함수는 필수입니다!')
        self._effect = effect
        
    @staticmethod
    def of(value):
        return IO(lambda: value)
      
    @staticmethod
    def from_func(f):
        return IO(f)
      
    def map(self, f):
        return IO(lambda: f(self._effect()))
      
    def chain(self, f):
        return f(self._effect())
      
    def run(self):
        return self._effect()
```

그리고 다음은 이러한 `IO` 모나드를 이용한 코드이다.

``` javascript
// javascript
const R = require('ramda');

const read = R.curry((db, id) => () => findFromDB(db, id));
const write = R.curry((error, message) => console.log(error ? 'error' : 'info', message));

const ioChain = IO.from(read(new StudentDB(), '444-44-4444'))
  .map(R.prop('firstname'))
  .map(_.startCase)
  .map(write(false));
ioChain.run();
```

``` python
# python
read = pydash.curry(lambda db, id: lambda: find_from_db(db, id))
write = pydash.curry(lambda error, message: print('error' if error else 'info', message))

io_chain = (IO.from_func(read(StudentDB(), '444-44-4444'))
            .map(prop('firstname'))
            .map(pydash.start_case)
            .map(write(False)))
io_chain.run()
```

이처럼 `IO` 모나드를 사용하면 확실히 IO 관련 연산을 한 번에 수행할 수 있도록 해주고, 부수효과를 내는 IO 연산을 다른 비즈니스 로직과 분리할 수 있다.