# 함수자

함수형에서 에러 처리를 하는 것도 사실상 명령형과 다를 바 없다. 즉 불안한 코드 주변에 안전망을 치자는 것이다. 명령형에서는 `try-catch` 블록으로 안전망을 쳤다. 함수형도 이와 같은 안전망의 패턴을 그대로 가져가되, 컨테이너라는 형태로 가져간다.

>***값을 컨테이너화 하는 행위는 함수형 프로그래밍의 기본적인 디자인 패턴이다. 그리고 이러한 감싼 값에 접근하는 유일한 방법은 연산(함수)을 컨테이너(감싸진 값)에 매핑하는 것이다.***

이러한 컨테이너의 간단한 형태를 살펴보도록 하자.

``` javascript
// javascript
class Wrapper {
  constructor(value) {
    this._value = value;
  }

  map(f) {
    return f(this._value);
  }
}
```

``` python
# python
class Wrapper:
    def __init__(self, value):
        self._value = value

    def map(self, f):
        return f(self._value)
```

이렇게 생성된 컨테이너는 다음과 같이 사용할 수 있다.

``` javascript
// javascript
const R = require('ramda');

const wrapped = new Wrapper(3);
wrapped.map(R.identity); // 3

const wrapped2 = new Wrapper('get');
wrapped2.map(R.toUpper); // GET
```

``` python
# python
import pydash

wrapped = Wrapper(3)
wrapped.map(pydash.identity) # 3

wrapped2 = Wrapper('get')
wrapped.map(pydash.to_upper) # GET
```

위에서 볼 수 있는 바처럼 직접적으로 값을 반환하여 사용할 수는 없다. 반환하려면 identity 조합기를 통해서만 반환할 수 있다. 값에 변화를 일으키는 것도 다른 함수를 통해서만 가능하다.

함수자도 기본적으로 이와 비슷하다. 함수를 통해서 반환된 값을 또 다시 컨테이너로 감싼다는 측면에서만 위와 다르다. 즉 함수자의 `map`은(`fmap`이라 칭하겠다) 다음과 같이 구성된다.

``` javascript
// javascript
fmap(f) {
  return new Wrapper(f(this._value));
}
```

``` python
# python
def fmap(self, f):
    return Wrapper(f(self._value))
```

함수를 위와 같이 구성하면 다음과 같이 체이닝 할 수 있다.

``` javascript
// javascript
const R = require('ramda');

const two = new Wrapper(2);
const add = R.curry((a, b) => a + b);

two.fmap(add(3)).fmap(add(2)).map(R.identity); // 7
```

``` python
# python
import pydash

two = Wrapper(2)
add = pydash.curry(lambda a, b: a + b)

two.fmap(add(3)).fmap(add(2)).map(pydash.identity) # 7
```

이런 함수자의 요건은 다음과 같다.
- 부수효과가 없어야 한다.
- 합성이 가능해야 한다.

>***함수자를 정리하면 콘텍스트를 생성 또는 추상하여 원본 값을 바꾸지 않은 상태로 안전하게 값을 꺼내어 연산을 수행하는 것이다.***

그러면 모나드는 무엇인가? 모나드는 함수자가 건드리는 '컨테이너' 중 하나다.